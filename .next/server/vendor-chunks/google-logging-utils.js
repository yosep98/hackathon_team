"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/google-logging-utils";
exports.ids = ["vendor-chunks/google-logging-utils"];
exports.modules = {

/***/ "(rsc)/./node_modules/google-logging-utils/build/src/colours.js":
/*!****************************************************************!*\
  !*** ./node_modules/google-logging-utils/build/src/colours.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2024 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Colours = void 0;\n/**\n * Handles figuring out if we can use ANSI colours and handing out the escape codes.\n *\n * This is for package-internal use only, and may change at any time.\n *\n * @private\n * @internal\n */\nclass Colours {\n    /**\n     * @param stream The stream (e.g. process.stderr)\n     * @returns true if the stream should have colourization enabled\n     */\n    static isEnabled(stream) {\n        return (stream && // May happen in browsers.\n            stream.isTTY &&\n            (typeof stream.getColorDepth === 'function'\n                ? stream.getColorDepth() > 2\n                : true));\n    }\n    static refresh() {\n        Colours.enabled = Colours.isEnabled(process === null || process === void 0 ? void 0 : process.stderr);\n        if (!this.enabled) {\n            Colours.reset = '';\n            Colours.bright = '';\n            Colours.dim = '';\n            Colours.red = '';\n            Colours.green = '';\n            Colours.yellow = '';\n            Colours.blue = '';\n            Colours.magenta = '';\n            Colours.cyan = '';\n            Colours.white = '';\n            Colours.grey = '';\n        }\n        else {\n            Colours.reset = '\\u001b[0m';\n            Colours.bright = '\\u001b[1m';\n            Colours.dim = '\\u001b[2m';\n            Colours.red = '\\u001b[31m';\n            Colours.green = '\\u001b[32m';\n            Colours.yellow = '\\u001b[33m';\n            Colours.blue = '\\u001b[34m';\n            Colours.magenta = '\\u001b[35m';\n            Colours.cyan = '\\u001b[36m';\n            Colours.white = '\\u001b[37m';\n            Colours.grey = '\\u001b[90m';\n        }\n    }\n}\nexports.Colours = Colours;\nColours.enabled = false;\nColours.reset = '';\nColours.bright = '';\nColours.dim = '';\nColours.red = '';\nColours.green = '';\nColours.yellow = '';\nColours.blue = '';\nColours.magenta = '';\nColours.cyan = '';\nColours.white = '';\nColours.grey = '';\nColours.refresh();\n//# sourceMappingURL=colours.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWxvZ2dpbmctdXRpbHMvYnVpbGQvc3JjL2NvbG91cnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYmFnLXlvc2ViL0Rlc2t0b3Av4YSR4YWp4YSH4YW14YSL4YWhL2hhY2thdGhvbl90ZWFtL215LWFwcC9ub2RlX21vZHVsZXMvZ29vZ2xlLWxvZ2dpbmctdXRpbHMvYnVpbGQvc3JjL2NvbG91cnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29sb3VycyA9IHZvaWQgMDtcbi8qKlxuICogSGFuZGxlcyBmaWd1cmluZyBvdXQgaWYgd2UgY2FuIHVzZSBBTlNJIGNvbG91cnMgYW5kIGhhbmRpbmcgb3V0IHRoZSBlc2NhcGUgY29kZXMuXG4gKlxuICogVGhpcyBpcyBmb3IgcGFja2FnZS1pbnRlcm5hbCB1c2Ugb25seSwgYW5kIG1heSBjaGFuZ2UgYXQgYW55IHRpbWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBDb2xvdXJzIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gc3RyZWFtIFRoZSBzdHJlYW0gKGUuZy4gcHJvY2Vzcy5zdGRlcnIpXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyZWFtIHNob3VsZCBoYXZlIGNvbG91cml6YXRpb24gZW5hYmxlZFxuICAgICAqL1xuICAgIHN0YXRpYyBpc0VuYWJsZWQoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiAoc3RyZWFtICYmIC8vIE1heSBoYXBwZW4gaW4gYnJvd3NlcnMuXG4gICAgICAgICAgICBzdHJlYW0uaXNUVFkgJiZcbiAgICAgICAgICAgICh0eXBlb2Ygc3RyZWFtLmdldENvbG9yRGVwdGggPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IHN0cmVhbS5nZXRDb2xvckRlcHRoKCkgPiAyXG4gICAgICAgICAgICAgICAgOiB0cnVlKSk7XG4gICAgfVxuICAgIHN0YXRpYyByZWZyZXNoKCkge1xuICAgICAgICBDb2xvdXJzLmVuYWJsZWQgPSBDb2xvdXJzLmlzRW5hYmxlZChwcm9jZXNzID09PSBudWxsIHx8IHByb2Nlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2Nlc3Muc3RkZXJyKTtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIENvbG91cnMucmVzZXQgPSAnJztcbiAgICAgICAgICAgIENvbG91cnMuYnJpZ2h0ID0gJyc7XG4gICAgICAgICAgICBDb2xvdXJzLmRpbSA9ICcnO1xuICAgICAgICAgICAgQ29sb3Vycy5yZWQgPSAnJztcbiAgICAgICAgICAgIENvbG91cnMuZ3JlZW4gPSAnJztcbiAgICAgICAgICAgIENvbG91cnMueWVsbG93ID0gJyc7XG4gICAgICAgICAgICBDb2xvdXJzLmJsdWUgPSAnJztcbiAgICAgICAgICAgIENvbG91cnMubWFnZW50YSA9ICcnO1xuICAgICAgICAgICAgQ29sb3Vycy5jeWFuID0gJyc7XG4gICAgICAgICAgICBDb2xvdXJzLndoaXRlID0gJyc7XG4gICAgICAgICAgICBDb2xvdXJzLmdyZXkgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIENvbG91cnMucmVzZXQgPSAnXFx1MDAxYlswbSc7XG4gICAgICAgICAgICBDb2xvdXJzLmJyaWdodCA9ICdcXHUwMDFiWzFtJztcbiAgICAgICAgICAgIENvbG91cnMuZGltID0gJ1xcdTAwMWJbMm0nO1xuICAgICAgICAgICAgQ29sb3Vycy5yZWQgPSAnXFx1MDAxYlszMW0nO1xuICAgICAgICAgICAgQ29sb3Vycy5ncmVlbiA9ICdcXHUwMDFiWzMybSc7XG4gICAgICAgICAgICBDb2xvdXJzLnllbGxvdyA9ICdcXHUwMDFiWzMzbSc7XG4gICAgICAgICAgICBDb2xvdXJzLmJsdWUgPSAnXFx1MDAxYlszNG0nO1xuICAgICAgICAgICAgQ29sb3Vycy5tYWdlbnRhID0gJ1xcdTAwMWJbMzVtJztcbiAgICAgICAgICAgIENvbG91cnMuY3lhbiA9ICdcXHUwMDFiWzM2bSc7XG4gICAgICAgICAgICBDb2xvdXJzLndoaXRlID0gJ1xcdTAwMWJbMzdtJztcbiAgICAgICAgICAgIENvbG91cnMuZ3JleSA9ICdcXHUwMDFiWzkwbSc7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNvbG91cnMgPSBDb2xvdXJzO1xuQ29sb3Vycy5lbmFibGVkID0gZmFsc2U7XG5Db2xvdXJzLnJlc2V0ID0gJyc7XG5Db2xvdXJzLmJyaWdodCA9ICcnO1xuQ29sb3Vycy5kaW0gPSAnJztcbkNvbG91cnMucmVkID0gJyc7XG5Db2xvdXJzLmdyZWVuID0gJyc7XG5Db2xvdXJzLnllbGxvdyA9ICcnO1xuQ29sb3Vycy5ibHVlID0gJyc7XG5Db2xvdXJzLm1hZ2VudGEgPSAnJztcbkNvbG91cnMuY3lhbiA9ICcnO1xuQ29sb3Vycy53aGl0ZSA9ICcnO1xuQ29sb3Vycy5ncmV5ID0gJyc7XG5Db2xvdXJzLnJlZnJlc2goKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG91cnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-logging-utils/build/src/colours.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-logging-utils/build/src/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/google-logging-utils/build/src/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright 2024 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./logging-utils */ \"(rsc)/./node_modules/google-logging-utils/build/src/logging-utils.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWxvZ2dpbmctdXRpbHMvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDZGQUFpQjtBQUN0QyIsInNvdXJjZXMiOlsiL1VzZXJzL2JhZy15b3NlYi9EZXNrdG9wL+GEkeGFqeGEh+GFteGEi+GFoS9oYWNrYXRob25fdGVhbS9teS1hcHAvbm9kZV9tb2R1bGVzL2dvb2dsZS1sb2dnaW5nLXV0aWxzL2J1aWxkL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-logging-utils/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-logging-utils/build/src/logging-utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-logging-utils/build/src/logging-utils.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright 2021-2024 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.env = exports.DebugLogBackendBase = exports.placeholder = exports.AdhocDebugLogger = exports.LogSeverity = void 0;\nexports.getNodeBackend = getNodeBackend;\nexports.getDebugBackend = getDebugBackend;\nexports.getStructuredBackend = getStructuredBackend;\nexports.setBackend = setBackend;\nexports.log = log;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst process = __importStar(__webpack_require__(/*! process */ \"process\"));\nconst util = __importStar(__webpack_require__(/*! util */ \"util\"));\nconst colours_1 = __webpack_require__(/*! ./colours */ \"(rsc)/./node_modules/google-logging-utils/build/src/colours.js\");\n// Some functions (as noted) are based on the Node standard library, from\n// the following file:\n//\n// https://github.com/nodejs/node/blob/main/lib/internal/util/debuglog.js\n/**\n * This module defines an ad-hoc debug logger for Google Cloud Platform\n * client libraries in Node. An ad-hoc debug logger is a tool which lets\n * users use an external, unified interface (in this case, environment\n * variables) to determine what logging they want to see at runtime. This\n * isn't necessarily fed into the console, but is meant to be under the\n * control of the user. The kind of logging that will be produced by this\n * is more like \"call retry happened\", not \"events you'd want to record\n * in Cloud Logger\".\n *\n * More for Googlers implementing libraries with it:\n * go/cloud-client-logging-design\n */\n/**\n * Possible log levels. These are a subset of Cloud Observability levels.\n * https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#LogSeverity\n */\nvar LogSeverity;\n(function (LogSeverity) {\n    LogSeverity[\"DEFAULT\"] = \"DEFAULT\";\n    LogSeverity[\"DEBUG\"] = \"DEBUG\";\n    LogSeverity[\"INFO\"] = \"INFO\";\n    LogSeverity[\"WARNING\"] = \"WARNING\";\n    LogSeverity[\"ERROR\"] = \"ERROR\";\n})(LogSeverity || (exports.LogSeverity = LogSeverity = {}));\n/**\n * Our logger instance. This actually contains the meat of dealing\n * with log lines, including EventEmitter. This contains the function\n * that will be passed back to users of the package.\n */\nclass AdhocDebugLogger extends events_1.EventEmitter {\n    /**\n     * @param upstream The backend will pass a function that will be\n     *   called whenever our logger function is invoked.\n     */\n    constructor(namespace, upstream) {\n        super();\n        this.namespace = namespace;\n        this.upstream = upstream;\n        this.func = Object.assign(this.invoke.bind(this), {\n            // Also add an instance pointer back to us.\n            instance: this,\n            // And pull over the EventEmitter functionality.\n            on: (event, listener) => this.on(event, listener),\n        });\n        // Convenience methods for log levels.\n        this.func.debug = (...args) => this.invokeSeverity(LogSeverity.DEBUG, ...args);\n        this.func.info = (...args) => this.invokeSeverity(LogSeverity.INFO, ...args);\n        this.func.warn = (...args) => this.invokeSeverity(LogSeverity.WARNING, ...args);\n        this.func.error = (...args) => this.invokeSeverity(LogSeverity.ERROR, ...args);\n        this.func.sublog = (namespace) => log(namespace, this.func);\n    }\n    invoke(fields, ...args) {\n        // Push out any upstream logger first.\n        if (this.upstream) {\n            try {\n                this.upstream(fields, ...args);\n            }\n            catch (e) {\n                // Swallow exceptions to avoid interfering with other logging.\n            }\n        }\n        // Emit sink events.\n        try {\n            this.emit('log', fields, args);\n        }\n        catch (e) {\n            // Swallow exceptions to avoid interfering with other logging.\n        }\n    }\n    invokeSeverity(severity, ...args) {\n        this.invoke({ severity }, ...args);\n    }\n}\nexports.AdhocDebugLogger = AdhocDebugLogger;\n/**\n * This can be used in place of a real logger while waiting for Promises or disabling logging.\n */\nexports.placeholder = new AdhocDebugLogger('', () => { }).func;\n/**\n * The base class for debug logging backends. It's possible to use this, but the\n * same non-guarantees above still apply (unstable interface, etc).\n *\n * @private\n * @internal\n */\nclass DebugLogBackendBase {\n    constructor() {\n        var _a;\n        this.cached = new Map();\n        this.filters = [];\n        this.filtersSet = false;\n        // Look for the Node config variable for what systems to enable. We'll store\n        // these for the log method below, which will call setFilters() once.\n        let nodeFlag = (_a = process.env[exports.env.nodeEnables]) !== null && _a !== void 0 ? _a : '*';\n        if (nodeFlag === 'all') {\n            nodeFlag = '*';\n        }\n        this.filters = nodeFlag.split(',');\n    }\n    log(namespace, fields, ...args) {\n        try {\n            if (!this.filtersSet) {\n                this.setFilters();\n                this.filtersSet = true;\n            }\n            let logger = this.cached.get(namespace);\n            if (!logger) {\n                logger = this.makeLogger(namespace);\n                this.cached.set(namespace, logger);\n            }\n            logger(fields, ...args);\n        }\n        catch (e) {\n            // Silently ignore all errors; we don't want them to interfere with\n            // the user's running app.\n            // e;\n            console.error(e);\n        }\n    }\n}\nexports.DebugLogBackendBase = DebugLogBackendBase;\n// The basic backend. This one definitely works, but it's less feature-filled.\n//\n// Rather than using util.debuglog, this implements the same basic logic directly.\n// The reason for this decision is that debuglog checks the value of the\n// NODE_DEBUG environment variable before any user code runs; we therefore\n// can't pipe our own enables into it (and util.debuglog will never print unless\n// the user duplicates it into NODE_DEBUG, which isn't reasonable).\n//\nclass NodeBackend extends DebugLogBackendBase {\n    constructor() {\n        super(...arguments);\n        // Default to allowing all systems, since we gate earlier based on whether the\n        // variable is empty.\n        this.enabledRegexp = /.*/g;\n    }\n    isEnabled(namespace) {\n        return this.enabledRegexp.test(namespace);\n    }\n    makeLogger(namespace) {\n        if (!this.enabledRegexp.test(namespace)) {\n            return () => { };\n        }\n        return (fields, ...args) => {\n            var _a;\n            // TODO: `fields` needs to be turned into a string here, one way or another.\n            const nscolour = `${colours_1.Colours.green}${namespace}${colours_1.Colours.reset}`;\n            const pid = `${colours_1.Colours.yellow}${process.pid}${colours_1.Colours.reset}`;\n            let level;\n            switch (fields.severity) {\n                case LogSeverity.ERROR:\n                    level = `${colours_1.Colours.red}${fields.severity}${colours_1.Colours.reset}`;\n                    break;\n                case LogSeverity.INFO:\n                    level = `${colours_1.Colours.magenta}${fields.severity}${colours_1.Colours.reset}`;\n                    break;\n                case LogSeverity.WARNING:\n                    level = `${colours_1.Colours.yellow}${fields.severity}${colours_1.Colours.reset}`;\n                    break;\n                default:\n                    level = (_a = fields.severity) !== null && _a !== void 0 ? _a : LogSeverity.DEFAULT;\n                    break;\n            }\n            const msg = util.formatWithOptions({ colors: colours_1.Colours.enabled }, ...args);\n            const filteredFields = Object.assign({}, fields);\n            delete filteredFields.severity;\n            const fieldsJson = Object.getOwnPropertyNames(filteredFields).length\n                ? JSON.stringify(filteredFields)\n                : '';\n            const fieldsColour = fieldsJson\n                ? `${colours_1.Colours.grey}${fieldsJson}${colours_1.Colours.reset}`\n                : '';\n            console.error('%s [%s|%s] %s%s', pid, nscolour, level, msg, fieldsJson ? ` ${fieldsColour}` : '');\n        };\n    }\n    // Regexp patterns below are from here:\n    // https://github.com/nodejs/node/blob/c0aebed4b3395bd65d54b18d1fd00f071002ac20/lib/internal/util/debuglog.js#L36\n    setFilters() {\n        const totalFilters = this.filters.join(',');\n        const regexp = totalFilters\n            .replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n            .replace(/\\*/g, '.*')\n            .replace(/,/g, '$|^');\n        this.enabledRegexp = new RegExp(`^${regexp}$`, 'i');\n    }\n}\n/**\n * @returns A backend based on Node util.debuglog; this is the default.\n */\nfunction getNodeBackend() {\n    return new NodeBackend();\n}\nclass DebugBackend extends DebugLogBackendBase {\n    constructor(pkg) {\n        super();\n        this.debugPkg = pkg;\n    }\n    makeLogger(namespace) {\n        const debugLogger = this.debugPkg(namespace);\n        return (fields, ...args) => {\n            // TODO: `fields` needs to be turned into a string here.\n            debugLogger(args[0], ...args.slice(1));\n        };\n    }\n    setFilters() {\n        var _a;\n        const existingFilters = (_a = process.env['NODE_DEBUG']) !== null && _a !== void 0 ? _a : '';\n        process.env['NODE_DEBUG'] = `${existingFilters}${existingFilters ? ',' : ''}${this.filters.join(',')}`;\n    }\n}\n/**\n * Creates a \"debug\" package backend. The user must call require('debug') and pass\n * the resulting object to this function.\n *\n * ```\n *  setBackend(getDebugBackend(require('debug')))\n * ```\n *\n * https://www.npmjs.com/package/debug\n *\n * Note: Google does not explicitly endorse or recommend this package; it's just\n * being provided as an option.\n *\n * @returns A backend based on the npm \"debug\" package.\n */\nfunction getDebugBackend(debugPkg) {\n    return new DebugBackend(debugPkg);\n}\n/**\n * This pretty much works like the Node logger, but it outputs structured\n * logging JSON matching Google Cloud's ingestion specs. Rather than handling\n * its own output, it wraps another backend. The passed backend must be a subclass\n * of `DebugLogBackendBase` (any of the backends exposed by this package will work).\n */\nclass StructuredBackend extends DebugLogBackendBase {\n    constructor(upstream) {\n        var _a;\n        super();\n        this.upstream = (_a = upstream) !== null && _a !== void 0 ? _a : undefined;\n    }\n    makeLogger(namespace) {\n        var _a;\n        const debugLogger = (_a = this.upstream) === null || _a === void 0 ? void 0 : _a.makeLogger(namespace);\n        return (fields, ...args) => {\n            var _a;\n            const severity = (_a = fields.severity) !== null && _a !== void 0 ? _a : LogSeverity.INFO;\n            const json = Object.assign({\n                severity,\n                message: util.format(...args),\n            }, fields);\n            const jsonString = JSON.stringify(json);\n            if (debugLogger) {\n                debugLogger(fields, jsonString);\n            }\n            else {\n                console.log('%s', jsonString);\n            }\n        };\n    }\n    setFilters() {\n        var _a;\n        (_a = this.upstream) === null || _a === void 0 ? void 0 : _a.setFilters();\n    }\n}\n/**\n * Creates a \"structured logging\" backend. This pretty much works like the\n * Node logger, but it outputs structured logging JSON matching Google\n * Cloud's ingestion specs instead of plain text.\n *\n * ```\n *  setBackend(getStructuredBackend())\n * ```\n *\n * @param upstream If you want to use something besides the Node backend to\n *   write the actual log lines into, pass that here.\n * @returns A backend based on Google Cloud structured logging.\n */\nfunction getStructuredBackend(upstream) {\n    return new StructuredBackend(upstream);\n}\n/**\n * The environment variables that we standardized on, for all ad-hoc logging.\n */\nexports.env = {\n    /**\n     * Filter wildcards specific to the Node syntax, and similar to the built-in\n     * utils.debuglog() environment variable. If missing, disables logging.\n     */\n    nodeEnables: 'GOOGLE_SDK_NODE_LOGGING',\n};\n// Keep a copy of all namespaced loggers so users can reliably .on() them.\n// Note that these cached functions will need to deal with changes in the backend.\nconst loggerCache = new Map();\n// Our current global backend. This might be:\nlet cachedBackend = undefined;\n/**\n * Set the backend to use for our log output.\n * - A backend object\n * - null to disable logging\n * - undefined for \"nothing yet\", defaults to the Node backend\n *\n * @param backend Results from one of the get*Backend() functions.\n */\nfunction setBackend(backend) {\n    cachedBackend = backend;\n    loggerCache.clear();\n}\n/**\n * Creates a logging function. Multiple calls to this with the same namespace\n * will produce the same logger, with the same event emitter hooks.\n *\n * Namespaces can be a simple string (\"system\" name), or a qualified string\n * (system:subsystem), which can be used for filtering, or for \"system:*\".\n *\n * @param namespace The namespace, a descriptive text string.\n * @returns A function you can call that works similar to console.log().\n */\nfunction log(namespace, parent) {\n    // If the enable environment variable isn't set, do nothing. The user\n    // can still choose to set a backend of their choice using the manual\n    // `setBackend()`.\n    if (!cachedBackend) {\n        const enablesFlag = process.env[exports.env.nodeEnables];\n        if (!enablesFlag) {\n            return exports.placeholder;\n        }\n    }\n    // This might happen mostly if the typings are dropped in a user's code,\n    // or if they're calling from JavaScript.\n    if (!namespace) {\n        return exports.placeholder;\n    }\n    // Handle sub-loggers.\n    if (parent) {\n        namespace = `${parent.instance.namespace}:${namespace}`;\n    }\n    // Reuse loggers so things like event sinks are persistent.\n    const existing = loggerCache.get(namespace);\n    if (existing) {\n        return existing.func;\n    }\n    // Do we have a backend yet?\n    if (cachedBackend === null) {\n        // Explicitly disabled.\n        return exports.placeholder;\n    }\n    else if (cachedBackend === undefined) {\n        // One hasn't been made yet, so default to Node.\n        cachedBackend = getNodeBackend();\n    }\n    // The logger is further wrapped so we can handle the backend changing out.\n    const logger = (() => {\n        let previousBackend = undefined;\n        const newLogger = new AdhocDebugLogger(namespace, (fields, ...args) => {\n            if (previousBackend !== cachedBackend) {\n                // Did the user pass a custom backend?\n                if (cachedBackend === null) {\n                    // Explicitly disabled.\n                    return;\n                }\n                else if (cachedBackend === undefined) {\n                    // One hasn't been made yet, so default to Node.\n                    cachedBackend = getNodeBackend();\n                }\n                previousBackend = cachedBackend;\n            }\n            cachedBackend === null || cachedBackend === void 0 ? void 0 : cachedBackend.log(namespace, fields, ...args);\n        });\n        return newLogger;\n    })();\n    loggerCache.set(namespace, logger);\n    return logger.func;\n}\n//# sourceMappingURL=logging-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWxvZ2dpbmctdXRpbHMvYnVpbGQvc3JjL2xvZ2dpbmctdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXLEdBQUcsMkJBQTJCLEdBQUcsbUJBQW1CLEdBQUcsd0JBQXdCLEdBQUcsbUJBQW1CO0FBQ2hILHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLGtCQUFrQjtBQUNsQixXQUFXO0FBQ1gsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsNkJBQTZCLG1CQUFPLENBQUMsd0JBQVM7QUFDOUMsMEJBQTBCLG1CQUFPLENBQUMsa0JBQU07QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMsaUZBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQixtQkFBbUIsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQ0FBcUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0IsRUFBRSxVQUFVLEVBQUUsd0JBQXdCO0FBQzlGLDJCQUEyQix5QkFBeUIsRUFBRSxZQUFZLEVBQUUsd0JBQXdCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBc0IsRUFBRSxnQkFBZ0IsRUFBRSx3QkFBd0I7QUFDakc7QUFDQTtBQUNBLCtCQUErQiwwQkFBMEIsRUFBRSxnQkFBZ0IsRUFBRSx3QkFBd0I7QUFDckc7QUFDQTtBQUNBLCtCQUErQix5QkFBeUIsRUFBRSxnQkFBZ0IsRUFBRSx3QkFBd0I7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxtQ0FBbUM7QUFDcEYsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCLEVBQUUsV0FBVyxFQUFFLHdCQUF3QjtBQUNuRjtBQUNBLHlGQUF5RixhQUFhO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCLEVBQUUsMkJBQTJCLEVBQUUsdUJBQXVCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEIsR0FBRyxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9iYWcteW9zZWIvRGVza3RvcC/hhJHhhanhhIfhhbXhhIvhhaEvaGFja2F0aG9uX3RlYW0vbXktYXBwL25vZGVfbW9kdWxlcy9nb29nbGUtbG9nZ2luZy11dGlscy9idWlsZC9zcmMvbG9nZ2luZy11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW52ID0gZXhwb3J0cy5EZWJ1Z0xvZ0JhY2tlbmRCYXNlID0gZXhwb3J0cy5wbGFjZWhvbGRlciA9IGV4cG9ydHMuQWRob2NEZWJ1Z0xvZ2dlciA9IGV4cG9ydHMuTG9nU2V2ZXJpdHkgPSB2b2lkIDA7XG5leHBvcnRzLmdldE5vZGVCYWNrZW5kID0gZ2V0Tm9kZUJhY2tlbmQ7XG5leHBvcnRzLmdldERlYnVnQmFja2VuZCA9IGdldERlYnVnQmFja2VuZDtcbmV4cG9ydHMuZ2V0U3RydWN0dXJlZEJhY2tlbmQgPSBnZXRTdHJ1Y3R1cmVkQmFja2VuZDtcbmV4cG9ydHMuc2V0QmFja2VuZCA9IHNldEJhY2tlbmQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHByb2Nlc3MgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInByb2Nlc3NcIikpO1xuY29uc3QgdXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidXRpbFwiKSk7XG5jb25zdCBjb2xvdXJzXzEgPSByZXF1aXJlKFwiLi9jb2xvdXJzXCIpO1xuLy8gU29tZSBmdW5jdGlvbnMgKGFzIG5vdGVkKSBhcmUgYmFzZWQgb24gdGhlIE5vZGUgc3RhbmRhcmQgbGlicmFyeSwgZnJvbVxuLy8gdGhlIGZvbGxvd2luZyBmaWxlOlxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21haW4vbGliL2ludGVybmFsL3V0aWwvZGVidWdsb2cuanNcbi8qKlxuICogVGhpcyBtb2R1bGUgZGVmaW5lcyBhbiBhZC1ob2MgZGVidWcgbG9nZ2VyIGZvciBHb29nbGUgQ2xvdWQgUGxhdGZvcm1cbiAqIGNsaWVudCBsaWJyYXJpZXMgaW4gTm9kZS4gQW4gYWQtaG9jIGRlYnVnIGxvZ2dlciBpcyBhIHRvb2wgd2hpY2ggbGV0c1xuICogdXNlcnMgdXNlIGFuIGV4dGVybmFsLCB1bmlmaWVkIGludGVyZmFjZSAoaW4gdGhpcyBjYXNlLCBlbnZpcm9ubWVudFxuICogdmFyaWFibGVzKSB0byBkZXRlcm1pbmUgd2hhdCBsb2dnaW5nIHRoZXkgd2FudCB0byBzZWUgYXQgcnVudGltZS4gVGhpc1xuICogaXNuJ3QgbmVjZXNzYXJpbHkgZmVkIGludG8gdGhlIGNvbnNvbGUsIGJ1dCBpcyBtZWFudCB0byBiZSB1bmRlciB0aGVcbiAqIGNvbnRyb2wgb2YgdGhlIHVzZXIuIFRoZSBraW5kIG9mIGxvZ2dpbmcgdGhhdCB3aWxsIGJlIHByb2R1Y2VkIGJ5IHRoaXNcbiAqIGlzIG1vcmUgbGlrZSBcImNhbGwgcmV0cnkgaGFwcGVuZWRcIiwgbm90IFwiZXZlbnRzIHlvdSdkIHdhbnQgdG8gcmVjb3JkXG4gKiBpbiBDbG91ZCBMb2dnZXJcIi5cbiAqXG4gKiBNb3JlIGZvciBHb29nbGVycyBpbXBsZW1lbnRpbmcgbGlicmFyaWVzIHdpdGggaXQ6XG4gKiBnby9jbG91ZC1jbGllbnQtbG9nZ2luZy1kZXNpZ25cbiAqL1xuLyoqXG4gKiBQb3NzaWJsZSBsb2cgbGV2ZWxzLiBUaGVzZSBhcmUgYSBzdWJzZXQgb2YgQ2xvdWQgT2JzZXJ2YWJpbGl0eSBsZXZlbHMuXG4gKiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vbG9nZ2luZy9kb2NzL3JlZmVyZW5jZS92Mi9yZXN0L3YyL0xvZ0VudHJ5I0xvZ1NldmVyaXR5XG4gKi9cbnZhciBMb2dTZXZlcml0eTtcbihmdW5jdGlvbiAoTG9nU2V2ZXJpdHkpIHtcbiAgICBMb2dTZXZlcml0eVtcIkRFRkFVTFRcIl0gPSBcIkRFRkFVTFRcIjtcbiAgICBMb2dTZXZlcml0eVtcIkRFQlVHXCJdID0gXCJERUJVR1wiO1xuICAgIExvZ1NldmVyaXR5W1wiSU5GT1wiXSA9IFwiSU5GT1wiO1xuICAgIExvZ1NldmVyaXR5W1wiV0FSTklOR1wiXSA9IFwiV0FSTklOR1wiO1xuICAgIExvZ1NldmVyaXR5W1wiRVJST1JcIl0gPSBcIkVSUk9SXCI7XG59KShMb2dTZXZlcml0eSB8fCAoZXhwb3J0cy5Mb2dTZXZlcml0eSA9IExvZ1NldmVyaXR5ID0ge30pKTtcbi8qKlxuICogT3VyIGxvZ2dlciBpbnN0YW5jZS4gVGhpcyBhY3R1YWxseSBjb250YWlucyB0aGUgbWVhdCBvZiBkZWFsaW5nXG4gKiB3aXRoIGxvZyBsaW5lcywgaW5jbHVkaW5nIEV2ZW50RW1pdHRlci4gVGhpcyBjb250YWlucyB0aGUgZnVuY3Rpb25cbiAqIHRoYXQgd2lsbCBiZSBwYXNzZWQgYmFjayB0byB1c2VycyBvZiB0aGUgcGFja2FnZS5cbiAqL1xuY2xhc3MgQWRob2NEZWJ1Z0xvZ2dlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHVwc3RyZWFtIFRoZSBiYWNrZW5kIHdpbGwgcGFzcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZVxuICAgICAqICAgY2FsbGVkIHdoZW5ldmVyIG91ciBsb2dnZXIgZnVuY3Rpb24gaXMgaW52b2tlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lc3BhY2UsIHVwc3RyZWFtKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgICB0aGlzLnVwc3RyZWFtID0gdXBzdHJlYW07XG4gICAgICAgIHRoaXMuZnVuYyA9IE9iamVjdC5hc3NpZ24odGhpcy5pbnZva2UuYmluZCh0aGlzKSwge1xuICAgICAgICAgICAgLy8gQWxzbyBhZGQgYW4gaW5zdGFuY2UgcG9pbnRlciBiYWNrIHRvIHVzLlxuICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgICAgICAgICAvLyBBbmQgcHVsbCBvdmVyIHRoZSBFdmVudEVtaXR0ZXIgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgICAgIG9uOiAoZXZlbnQsIGxpc3RlbmVyKSA9PiB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lciksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDb252ZW5pZW5jZSBtZXRob2RzIGZvciBsb2cgbGV2ZWxzLlxuICAgICAgICB0aGlzLmZ1bmMuZGVidWcgPSAoLi4uYXJncykgPT4gdGhpcy5pbnZva2VTZXZlcml0eShMb2dTZXZlcml0eS5ERUJVRywgLi4uYXJncyk7XG4gICAgICAgIHRoaXMuZnVuYy5pbmZvID0gKC4uLmFyZ3MpID0+IHRoaXMuaW52b2tlU2V2ZXJpdHkoTG9nU2V2ZXJpdHkuSU5GTywgLi4uYXJncyk7XG4gICAgICAgIHRoaXMuZnVuYy53YXJuID0gKC4uLmFyZ3MpID0+IHRoaXMuaW52b2tlU2V2ZXJpdHkoTG9nU2V2ZXJpdHkuV0FSTklORywgLi4uYXJncyk7XG4gICAgICAgIHRoaXMuZnVuYy5lcnJvciA9ICguLi5hcmdzKSA9PiB0aGlzLmludm9rZVNldmVyaXR5KExvZ1NldmVyaXR5LkVSUk9SLCAuLi5hcmdzKTtcbiAgICAgICAgdGhpcy5mdW5jLnN1YmxvZyA9IChuYW1lc3BhY2UpID0+IGxvZyhuYW1lc3BhY2UsIHRoaXMuZnVuYyk7XG4gICAgfVxuICAgIGludm9rZShmaWVsZHMsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gUHVzaCBvdXQgYW55IHVwc3RyZWFtIGxvZ2dlciBmaXJzdC5cbiAgICAgICAgaWYgKHRoaXMudXBzdHJlYW0pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cHN0cmVhbShmaWVsZHMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBTd2FsbG93IGV4Y2VwdGlvbnMgdG8gYXZvaWQgaW50ZXJmZXJpbmcgd2l0aCBvdGhlciBsb2dnaW5nLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVtaXQgc2luayBldmVudHMuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2xvZycsIGZpZWxkcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFN3YWxsb3cgZXhjZXB0aW9ucyB0byBhdm9pZCBpbnRlcmZlcmluZyB3aXRoIG90aGVyIGxvZ2dpbmcuXG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52b2tlU2V2ZXJpdHkoc2V2ZXJpdHksIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5pbnZva2UoeyBzZXZlcml0eSB9LCAuLi5hcmdzKTtcbiAgICB9XG59XG5leHBvcnRzLkFkaG9jRGVidWdMb2dnZXIgPSBBZGhvY0RlYnVnTG9nZ2VyO1xuLyoqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIGluIHBsYWNlIG9mIGEgcmVhbCBsb2dnZXIgd2hpbGUgd2FpdGluZyBmb3IgUHJvbWlzZXMgb3IgZGlzYWJsaW5nIGxvZ2dpbmcuXG4gKi9cbmV4cG9ydHMucGxhY2Vob2xkZXIgPSBuZXcgQWRob2NEZWJ1Z0xvZ2dlcignJywgKCkgPT4geyB9KS5mdW5jO1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgZGVidWcgbG9nZ2luZyBiYWNrZW5kcy4gSXQncyBwb3NzaWJsZSB0byB1c2UgdGhpcywgYnV0IHRoZVxuICogc2FtZSBub24tZ3VhcmFudGVlcyBhYm92ZSBzdGlsbCBhcHBseSAodW5zdGFibGUgaW50ZXJmYWNlLCBldGMpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRGVidWdMb2dCYWNrZW5kQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5jYWNoZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgICAgICB0aGlzLmZpbHRlcnNTZXQgPSBmYWxzZTtcbiAgICAgICAgLy8gTG9vayBmb3IgdGhlIE5vZGUgY29uZmlnIHZhcmlhYmxlIGZvciB3aGF0IHN5c3RlbXMgdG8gZW5hYmxlLiBXZSdsbCBzdG9yZVxuICAgICAgICAvLyB0aGVzZSBmb3IgdGhlIGxvZyBtZXRob2QgYmVsb3csIHdoaWNoIHdpbGwgY2FsbCBzZXRGaWx0ZXJzKCkgb25jZS5cbiAgICAgICAgbGV0IG5vZGVGbGFnID0gKF9hID0gcHJvY2Vzcy5lbnZbZXhwb3J0cy5lbnYubm9kZUVuYWJsZXNdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnKic7XG4gICAgICAgIGlmIChub2RlRmxhZyA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgIG5vZGVGbGFnID0gJyonO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IG5vZGVGbGFnLnNwbGl0KCcsJyk7XG4gICAgfVxuICAgIGxvZyhuYW1lc3BhY2UsIGZpZWxkcywgLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpbHRlcnNTZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZpbHRlcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnNTZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxvZ2dlciA9IHRoaXMuY2FjaGVkLmdldChuYW1lc3BhY2UpO1xuICAgICAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIgPSB0aGlzLm1ha2VMb2dnZXIobmFtZXNwYWNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZC5zZXQobmFtZXNwYWNlLCBsb2dnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyKGZpZWxkcywgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFNpbGVudGx5IGlnbm9yZSBhbGwgZXJyb3JzOyB3ZSBkb24ndCB3YW50IHRoZW0gdG8gaW50ZXJmZXJlIHdpdGhcbiAgICAgICAgICAgIC8vIHRoZSB1c2VyJ3MgcnVubmluZyBhcHAuXG4gICAgICAgICAgICAvLyBlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGVidWdMb2dCYWNrZW5kQmFzZSA9IERlYnVnTG9nQmFja2VuZEJhc2U7XG4vLyBUaGUgYmFzaWMgYmFja2VuZC4gVGhpcyBvbmUgZGVmaW5pdGVseSB3b3JrcywgYnV0IGl0J3MgbGVzcyBmZWF0dXJlLWZpbGxlZC5cbi8vXG4vLyBSYXRoZXIgdGhhbiB1c2luZyB1dGlsLmRlYnVnbG9nLCB0aGlzIGltcGxlbWVudHMgdGhlIHNhbWUgYmFzaWMgbG9naWMgZGlyZWN0bHkuXG4vLyBUaGUgcmVhc29uIGZvciB0aGlzIGRlY2lzaW9uIGlzIHRoYXQgZGVidWdsb2cgY2hlY2tzIHRoZSB2YWx1ZSBvZiB0aGVcbi8vIE5PREVfREVCVUcgZW52aXJvbm1lbnQgdmFyaWFibGUgYmVmb3JlIGFueSB1c2VyIGNvZGUgcnVuczsgd2UgdGhlcmVmb3JlXG4vLyBjYW4ndCBwaXBlIG91ciBvd24gZW5hYmxlcyBpbnRvIGl0IChhbmQgdXRpbC5kZWJ1Z2xvZyB3aWxsIG5ldmVyIHByaW50IHVubGVzc1xuLy8gdGhlIHVzZXIgZHVwbGljYXRlcyBpdCBpbnRvIE5PREVfREVCVUcsIHdoaWNoIGlzbid0IHJlYXNvbmFibGUpLlxuLy9cbmNsYXNzIE5vZGVCYWNrZW5kIGV4dGVuZHMgRGVidWdMb2dCYWNrZW5kQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIERlZmF1bHQgdG8gYWxsb3dpbmcgYWxsIHN5c3RlbXMsIHNpbmNlIHdlIGdhdGUgZWFybGllciBiYXNlZCBvbiB3aGV0aGVyIHRoZVxuICAgICAgICAvLyB2YXJpYWJsZSBpcyBlbXB0eS5cbiAgICAgICAgdGhpcy5lbmFibGVkUmVnZXhwID0gLy4qL2c7XG4gICAgfVxuICAgIGlzRW5hYmxlZChuYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZFJlZ2V4cC50ZXN0KG5hbWVzcGFjZSk7XG4gICAgfVxuICAgIG1ha2VMb2dnZXIobmFtZXNwYWNlKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkUmVnZXhwLnRlc3QobmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGZpZWxkcywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gVE9ETzogYGZpZWxkc2AgbmVlZHMgdG8gYmUgdHVybmVkIGludG8gYSBzdHJpbmcgaGVyZSwgb25lIHdheSBvciBhbm90aGVyLlxuICAgICAgICAgICAgY29uc3QgbnNjb2xvdXIgPSBgJHtjb2xvdXJzXzEuQ29sb3Vycy5ncmVlbn0ke25hbWVzcGFjZX0ke2NvbG91cnNfMS5Db2xvdXJzLnJlc2V0fWA7XG4gICAgICAgICAgICBjb25zdCBwaWQgPSBgJHtjb2xvdXJzXzEuQ29sb3Vycy55ZWxsb3d9JHtwcm9jZXNzLnBpZH0ke2NvbG91cnNfMS5Db2xvdXJzLnJlc2V0fWA7XG4gICAgICAgICAgICBsZXQgbGV2ZWw7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkcy5zZXZlcml0eSkge1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nU2V2ZXJpdHkuRVJST1I6XG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gYCR7Y29sb3Vyc18xLkNvbG91cnMucmVkfSR7ZmllbGRzLnNldmVyaXR5fSR7Y29sb3Vyc18xLkNvbG91cnMucmVzZXR9YDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dTZXZlcml0eS5JTkZPOlxuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IGAke2NvbG91cnNfMS5Db2xvdXJzLm1hZ2VudGF9JHtmaWVsZHMuc2V2ZXJpdHl9JHtjb2xvdXJzXzEuQ29sb3Vycy5yZXNldH1gO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExvZ1NldmVyaXR5LldBUk5JTkc6XG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gYCR7Y29sb3Vyc18xLkNvbG91cnMueWVsbG93fSR7ZmllbGRzLnNldmVyaXR5fSR7Y29sb3Vyc18xLkNvbG91cnMucmVzZXR9YDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSAoX2EgPSBmaWVsZHMuc2V2ZXJpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ1NldmVyaXR5LkRFRkFVTFQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXNnID0gdXRpbC5mb3JtYXRXaXRoT3B0aW9ucyh7IGNvbG9yczogY29sb3Vyc18xLkNvbG91cnMuZW5hYmxlZCB9LCAuLi5hcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkRmllbGRzID0gT2JqZWN0LmFzc2lnbih7fSwgZmllbGRzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBmaWx0ZXJlZEZpZWxkcy5zZXZlcml0eTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkc0pzb24gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhmaWx0ZXJlZEZpZWxkcykubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeShmaWx0ZXJlZEZpZWxkcylcbiAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgY29uc3QgZmllbGRzQ29sb3VyID0gZmllbGRzSnNvblxuICAgICAgICAgICAgICAgID8gYCR7Y29sb3Vyc18xLkNvbG91cnMuZ3JleX0ke2ZpZWxkc0pzb259JHtjb2xvdXJzXzEuQ29sb3Vycy5yZXNldH1gXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzIFslc3wlc10gJXMlcycsIHBpZCwgbnNjb2xvdXIsIGxldmVsLCBtc2csIGZpZWxkc0pzb24gPyBgICR7ZmllbGRzQ29sb3VyfWAgOiAnJyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFJlZ2V4cCBwYXR0ZXJucyBiZWxvdyBhcmUgZnJvbSBoZXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2MwYWViZWQ0YjMzOTViZDY1ZDU0YjE4ZDFmZDAwZjA3MTAwMmFjMjAvbGliL2ludGVybmFsL3V0aWwvZGVidWdsb2cuanMjTDM2XG4gICAgc2V0RmlsdGVycygpIHtcbiAgICAgICAgY29uc3QgdG90YWxGaWx0ZXJzID0gdGhpcy5maWx0ZXJzLmpvaW4oJywnKTtcbiAgICAgICAgY29uc3QgcmVnZXhwID0gdG90YWxGaWx0ZXJzXG4gICAgICAgICAgICAucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZywgJ1xcXFwkJicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwqL2csICcuKicpXG4gICAgICAgICAgICAucmVwbGFjZSgvLC9nLCAnJHxeJyk7XG4gICAgICAgIHRoaXMuZW5hYmxlZFJlZ2V4cCA9IG5ldyBSZWdFeHAoYF4ke3JlZ2V4cH0kYCwgJ2knKTtcbiAgICB9XG59XG4vKipcbiAqIEByZXR1cm5zIEEgYmFja2VuZCBiYXNlZCBvbiBOb2RlIHV0aWwuZGVidWdsb2c7IHRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVCYWNrZW5kKCkge1xuICAgIHJldHVybiBuZXcgTm9kZUJhY2tlbmQoKTtcbn1cbmNsYXNzIERlYnVnQmFja2VuZCBleHRlbmRzIERlYnVnTG9nQmFja2VuZEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBrZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRlYnVnUGtnID0gcGtnO1xuICAgIH1cbiAgICBtYWtlTG9nZ2VyKG5hbWVzcGFjZSkge1xuICAgICAgICBjb25zdCBkZWJ1Z0xvZ2dlciA9IHRoaXMuZGVidWdQa2cobmFtZXNwYWNlKTtcbiAgICAgICAgcmV0dXJuIChmaWVsZHMsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE86IGBmaWVsZHNgIG5lZWRzIHRvIGJlIHR1cm5lZCBpbnRvIGEgc3RyaW5nIGhlcmUuXG4gICAgICAgICAgICBkZWJ1Z0xvZ2dlcihhcmdzWzBdLCAuLi5hcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0RmlsdGVycygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBleGlzdGluZ0ZpbHRlcnMgPSAoX2EgPSBwcm9jZXNzLmVudlsnTk9ERV9ERUJVRyddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgcHJvY2Vzcy5lbnZbJ05PREVfREVCVUcnXSA9IGAke2V4aXN0aW5nRmlsdGVyc30ke2V4aXN0aW5nRmlsdGVycyA/ICcsJyA6ICcnfSR7dGhpcy5maWx0ZXJzLmpvaW4oJywnKX1gO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIFwiZGVidWdcIiBwYWNrYWdlIGJhY2tlbmQuIFRoZSB1c2VyIG11c3QgY2FsbCByZXF1aXJlKCdkZWJ1ZycpIGFuZCBwYXNzXG4gKiB0aGUgcmVzdWx0aW5nIG9iamVjdCB0byB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIGBgYFxuICogIHNldEJhY2tlbmQoZ2V0RGVidWdCYWNrZW5kKHJlcXVpcmUoJ2RlYnVnJykpKVxuICogYGBgXG4gKlxuICogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVidWdcbiAqXG4gKiBOb3RlOiBHb29nbGUgZG9lcyBub3QgZXhwbGljaXRseSBlbmRvcnNlIG9yIHJlY29tbWVuZCB0aGlzIHBhY2thZ2U7IGl0J3MganVzdFxuICogYmVpbmcgcHJvdmlkZWQgYXMgYW4gb3B0aW9uLlxuICpcbiAqIEByZXR1cm5zIEEgYmFja2VuZCBiYXNlZCBvbiB0aGUgbnBtIFwiZGVidWdcIiBwYWNrYWdlLlxuICovXG5mdW5jdGlvbiBnZXREZWJ1Z0JhY2tlbmQoZGVidWdQa2cpIHtcbiAgICByZXR1cm4gbmV3IERlYnVnQmFja2VuZChkZWJ1Z1BrZyk7XG59XG4vKipcbiAqIFRoaXMgcHJldHR5IG11Y2ggd29ya3MgbGlrZSB0aGUgTm9kZSBsb2dnZXIsIGJ1dCBpdCBvdXRwdXRzIHN0cnVjdHVyZWRcbiAqIGxvZ2dpbmcgSlNPTiBtYXRjaGluZyBHb29nbGUgQ2xvdWQncyBpbmdlc3Rpb24gc3BlY3MuIFJhdGhlciB0aGFuIGhhbmRsaW5nXG4gKiBpdHMgb3duIG91dHB1dCwgaXQgd3JhcHMgYW5vdGhlciBiYWNrZW5kLiBUaGUgcGFzc2VkIGJhY2tlbmQgbXVzdCBiZSBhIHN1YmNsYXNzXG4gKiBvZiBgRGVidWdMb2dCYWNrZW5kQmFzZWAgKGFueSBvZiB0aGUgYmFja2VuZHMgZXhwb3NlZCBieSB0aGlzIHBhY2thZ2Ugd2lsbCB3b3JrKS5cbiAqL1xuY2xhc3MgU3RydWN0dXJlZEJhY2tlbmQgZXh0ZW5kcyBEZWJ1Z0xvZ0JhY2tlbmRCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih1cHN0cmVhbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudXBzdHJlYW0gPSAoX2EgPSB1cHN0cmVhbSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBtYWtlTG9nZ2VyKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGRlYnVnTG9nZ2VyID0gKF9hID0gdGhpcy51cHN0cmVhbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1ha2VMb2dnZXIobmFtZXNwYWNlKTtcbiAgICAgICAgcmV0dXJuIChmaWVsZHMsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHNldmVyaXR5ID0gKF9hID0gZmllbGRzLnNldmVyaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dTZXZlcml0eS5JTkZPO1xuICAgICAgICAgICAgY29uc3QganNvbiA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHNldmVyaXR5LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHV0aWwuZm9ybWF0KC4uLmFyZ3MpLFxuICAgICAgICAgICAgfSwgZmllbGRzKTtcbiAgICAgICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShqc29uKTtcbiAgICAgICAgICAgIGlmIChkZWJ1Z0xvZ2dlcikge1xuICAgICAgICAgICAgICAgIGRlYnVnTG9nZ2VyKGZpZWxkcywganNvblN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnJXMnLCBqc29uU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0RmlsdGVycygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnVwc3RyZWFtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0RmlsdGVycygpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIFwic3RydWN0dXJlZCBsb2dnaW5nXCIgYmFja2VuZC4gVGhpcyBwcmV0dHkgbXVjaCB3b3JrcyBsaWtlIHRoZVxuICogTm9kZSBsb2dnZXIsIGJ1dCBpdCBvdXRwdXRzIHN0cnVjdHVyZWQgbG9nZ2luZyBKU09OIG1hdGNoaW5nIEdvb2dsZVxuICogQ2xvdWQncyBpbmdlc3Rpb24gc3BlY3MgaW5zdGVhZCBvZiBwbGFpbiB0ZXh0LlxuICpcbiAqIGBgYFxuICogIHNldEJhY2tlbmQoZ2V0U3RydWN0dXJlZEJhY2tlbmQoKSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB1cHN0cmVhbSBJZiB5b3Ugd2FudCB0byB1c2Ugc29tZXRoaW5nIGJlc2lkZXMgdGhlIE5vZGUgYmFja2VuZCB0b1xuICogICB3cml0ZSB0aGUgYWN0dWFsIGxvZyBsaW5lcyBpbnRvLCBwYXNzIHRoYXQgaGVyZS5cbiAqIEByZXR1cm5zIEEgYmFja2VuZCBiYXNlZCBvbiBHb29nbGUgQ2xvdWQgc3RydWN0dXJlZCBsb2dnaW5nLlxuICovXG5mdW5jdGlvbiBnZXRTdHJ1Y3R1cmVkQmFja2VuZCh1cHN0cmVhbSkge1xuICAgIHJldHVybiBuZXcgU3RydWN0dXJlZEJhY2tlbmQodXBzdHJlYW0pO1xufVxuLyoqXG4gKiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRoYXQgd2Ugc3RhbmRhcmRpemVkIG9uLCBmb3IgYWxsIGFkLWhvYyBsb2dnaW5nLlxuICovXG5leHBvcnRzLmVudiA9IHtcbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgd2lsZGNhcmRzIHNwZWNpZmljIHRvIHRoZSBOb2RlIHN5bnRheCwgYW5kIHNpbWlsYXIgdG8gdGhlIGJ1aWx0LWluXG4gICAgICogdXRpbHMuZGVidWdsb2coKSBlbnZpcm9ubWVudCB2YXJpYWJsZS4gSWYgbWlzc2luZywgZGlzYWJsZXMgbG9nZ2luZy5cbiAgICAgKi9cbiAgICBub2RlRW5hYmxlczogJ0dPT0dMRV9TREtfTk9ERV9MT0dHSU5HJyxcbn07XG4vLyBLZWVwIGEgY29weSBvZiBhbGwgbmFtZXNwYWNlZCBsb2dnZXJzIHNvIHVzZXJzIGNhbiByZWxpYWJseSAub24oKSB0aGVtLlxuLy8gTm90ZSB0aGF0IHRoZXNlIGNhY2hlZCBmdW5jdGlvbnMgd2lsbCBuZWVkIHRvIGRlYWwgd2l0aCBjaGFuZ2VzIGluIHRoZSBiYWNrZW5kLlxuY29uc3QgbG9nZ2VyQ2FjaGUgPSBuZXcgTWFwKCk7XG4vLyBPdXIgY3VycmVudCBnbG9iYWwgYmFja2VuZC4gVGhpcyBtaWdodCBiZTpcbmxldCBjYWNoZWRCYWNrZW5kID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBTZXQgdGhlIGJhY2tlbmQgdG8gdXNlIGZvciBvdXIgbG9nIG91dHB1dC5cbiAqIC0gQSBiYWNrZW5kIG9iamVjdFxuICogLSBudWxsIHRvIGRpc2FibGUgbG9nZ2luZ1xuICogLSB1bmRlZmluZWQgZm9yIFwibm90aGluZyB5ZXRcIiwgZGVmYXVsdHMgdG8gdGhlIE5vZGUgYmFja2VuZFxuICpcbiAqIEBwYXJhbSBiYWNrZW5kIFJlc3VsdHMgZnJvbSBvbmUgb2YgdGhlIGdldCpCYWNrZW5kKCkgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBzZXRCYWNrZW5kKGJhY2tlbmQpIHtcbiAgICBjYWNoZWRCYWNrZW5kID0gYmFja2VuZDtcbiAgICBsb2dnZXJDYWNoZS5jbGVhcigpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbG9nZ2luZyBmdW5jdGlvbi4gTXVsdGlwbGUgY2FsbHMgdG8gdGhpcyB3aXRoIHRoZSBzYW1lIG5hbWVzcGFjZVxuICogd2lsbCBwcm9kdWNlIHRoZSBzYW1lIGxvZ2dlciwgd2l0aCB0aGUgc2FtZSBldmVudCBlbWl0dGVyIGhvb2tzLlxuICpcbiAqIE5hbWVzcGFjZXMgY2FuIGJlIGEgc2ltcGxlIHN0cmluZyAoXCJzeXN0ZW1cIiBuYW1lKSwgb3IgYSBxdWFsaWZpZWQgc3RyaW5nXG4gKiAoc3lzdGVtOnN1YnN5c3RlbSksIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBmaWx0ZXJpbmcsIG9yIGZvciBcInN5c3RlbToqXCIuXG4gKlxuICogQHBhcmFtIG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlLCBhIGRlc2NyaXB0aXZlIHRleHQgc3RyaW5nLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB5b3UgY2FuIGNhbGwgdGhhdCB3b3JrcyBzaW1pbGFyIHRvIGNvbnNvbGUubG9nKCkuXG4gKi9cbmZ1bmN0aW9uIGxvZyhuYW1lc3BhY2UsIHBhcmVudCkge1xuICAgIC8vIElmIHRoZSBlbmFibGUgZW52aXJvbm1lbnQgdmFyaWFibGUgaXNuJ3Qgc2V0LCBkbyBub3RoaW5nLiBUaGUgdXNlclxuICAgIC8vIGNhbiBzdGlsbCBjaG9vc2UgdG8gc2V0IGEgYmFja2VuZCBvZiB0aGVpciBjaG9pY2UgdXNpbmcgdGhlIG1hbnVhbFxuICAgIC8vIGBzZXRCYWNrZW5kKClgLlxuICAgIGlmICghY2FjaGVkQmFja2VuZCkge1xuICAgICAgICBjb25zdCBlbmFibGVzRmxhZyA9IHByb2Nlc3MuZW52W2V4cG9ydHMuZW52Lm5vZGVFbmFibGVzXTtcbiAgICAgICAgaWYgKCFlbmFibGVzRmxhZykge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMucGxhY2Vob2xkZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBtaWdodCBoYXBwZW4gbW9zdGx5IGlmIHRoZSB0eXBpbmdzIGFyZSBkcm9wcGVkIGluIGEgdXNlcidzIGNvZGUsXG4gICAgLy8gb3IgaWYgdGhleSdyZSBjYWxsaW5nIGZyb20gSmF2YVNjcmlwdC5cbiAgICBpZiAoIW5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5wbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgLy8gSGFuZGxlIHN1Yi1sb2dnZXJzLlxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gYCR7cGFyZW50Lmluc3RhbmNlLm5hbWVzcGFjZX06JHtuYW1lc3BhY2V9YDtcbiAgICB9XG4gICAgLy8gUmV1c2UgbG9nZ2VycyBzbyB0aGluZ3MgbGlrZSBldmVudCBzaW5rcyBhcmUgcGVyc2lzdGVudC5cbiAgICBjb25zdCBleGlzdGluZyA9IGxvZ2dlckNhY2hlLmdldChuYW1lc3BhY2UpO1xuICAgIGlmIChleGlzdGluZykge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmcuZnVuYztcbiAgICB9XG4gICAgLy8gRG8gd2UgaGF2ZSBhIGJhY2tlbmQgeWV0P1xuICAgIGlmIChjYWNoZWRCYWNrZW5kID09PSBudWxsKSB7XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgZGlzYWJsZWQuXG4gICAgICAgIHJldHVybiBleHBvcnRzLnBsYWNlaG9sZGVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYWNoZWRCYWNrZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gT25lIGhhc24ndCBiZWVuIG1hZGUgeWV0LCBzbyBkZWZhdWx0IHRvIE5vZGUuXG4gICAgICAgIGNhY2hlZEJhY2tlbmQgPSBnZXROb2RlQmFja2VuZCgpO1xuICAgIH1cbiAgICAvLyBUaGUgbG9nZ2VyIGlzIGZ1cnRoZXIgd3JhcHBlZCBzbyB3ZSBjYW4gaGFuZGxlIHRoZSBiYWNrZW5kIGNoYW5naW5nIG91dC5cbiAgICBjb25zdCBsb2dnZXIgPSAoKCkgPT4ge1xuICAgICAgICBsZXQgcHJldmlvdXNCYWNrZW5kID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBuZXdMb2dnZXIgPSBuZXcgQWRob2NEZWJ1Z0xvZ2dlcihuYW1lc3BhY2UsIChmaWVsZHMsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0JhY2tlbmQgIT09IGNhY2hlZEJhY2tlbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBEaWQgdGhlIHVzZXIgcGFzcyBhIGN1c3RvbSBiYWNrZW5kP1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRCYWNrZW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgZGlzYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2FjaGVkQmFja2VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9uZSBoYXNuJ3QgYmVlbiBtYWRlIHlldCwgc28gZGVmYXVsdCB0byBOb2RlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZWRCYWNrZW5kID0gZ2V0Tm9kZUJhY2tlbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNCYWNrZW5kID0gY2FjaGVkQmFja2VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhY2hlZEJhY2tlbmQgPT09IG51bGwgfHwgY2FjaGVkQmFja2VuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FjaGVkQmFja2VuZC5sb2cobmFtZXNwYWNlLCBmaWVsZHMsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld0xvZ2dlcjtcbiAgICB9KSgpO1xuICAgIGxvZ2dlckNhY2hlLnNldChuYW1lc3BhY2UsIGxvZ2dlcik7XG4gICAgcmV0dXJuIGxvZ2dlci5mdW5jO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-logging-utils/build/src/logging-utils.js\n");

/***/ })

};
;